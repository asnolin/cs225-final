\documentclass{article}
\title{CS225 Final Project Writeup}
\author{Andrew Nolin \\ git@asnolin \and Jared Wiggett \\ git@jwiggett}
\date{\today}

\begin{document}
\maketitle
\section*{Simply Typed Lambda Calculus with Exceptions}
We have implemented small step semantics and typing relations for the simply typed lambda calculus extended with exception terms as defined in Chapter 14 of Benjamin C. Pierce's Types and Programming Languages.

\paragraph{Base Language: Phase I}
The base language we used was the simply typed lambda calculus from Chapter 9 of TAPL. This calculus contains terms (variables, abstractions, and applications), values, types and a typing context as well as small step semantics rules. To implement this, we started with the untyped lambda calculus of Chapter 5 of TAPL, which did not include types or a typing context. We implemented variables as strings, abstractions as a tuple containing a string and term, and application as a tuple of two terms. We didn't include types at first because Chapter 5 is untyped and therefore doesn't include them. Our only original value was the abstraction value, which was also modeled as a tuple of string and term. To implement a step function, we added a result type to our program enumerated as Stuck, Step of term, or Val of value. We also added helper functions for 'translating' values to terms for the step function, for finding the free variables in a given term, and for enforcing unique variables in a given term.
\paragraph{Base Language: Phase II}
After the implementation of the untyped lambda calculus of Chapter 5, we moved on to the implementation of the simply-typed lambda calculus of Chapter 9 in TAPL. This required the definition of types, of which we used only two at first: the Unit type and the Function type, which maps one type to another. In other words, our original terms were restricted to types Unit \(\rightarrow\) Unit \(\rightarrow\) ... of arbitrary length. After this we implemented Bool types, including True, False, and If statements, True and False values, and small step semantics for these terms. We implemented a type environment as a string set map which made functions involving the type environment easy to manage; we could simply manipulate sets of these maps - union them, subtract elements, etc. Using these forms, we implemented an infer function that returns the type of any given term in our language. This followed definitions and specifications of Chapters 3, 5, and 9 of TAPL. To this point, we had our entire base language implemented.
\paragraph{Extended Language}
We then endeavored to extend this base language with exceptions. This was carried out in three phases in correspondance with the new forms, semantics, and typing relations defined on pages 172, 174, and 175 of TAPL. First, we added Errors themselves. We decided they should take a type to satisfy the typing relation T-Error. We also added a result type RError to allow the step function to accommodate intermediate Error results. We implemented E-AppErr1 and E-AppErr2 as extensions to our previous E-App rules from Chapters 5 and 9. Then we implemented the try-with syntactical forms of page 174. This included a new term TryWith of term * term, new evaluation rules E-TryV, E-TryError, and E-Try, and the new typing rule T-Try. T-Try was overwritten in the next phase, where we added support for raise statements. This included seven new typing rules, the definition of a new result type RRaise for intermediate step results and a new Exception of ty type. This allowed us to modify some of the earlier rules to allow for exception types, specifically T-Try. T-Exn also took advantage of the new exception type.
\paragraph{Applications}
Exception handling is a feature in most modern programming languages. It allows the programmer to have an error caused by the environment or user error, without the program crashing. An error caused by the environment could be a missing file, unavailable resource, or any event that could change what is assumed by the programmer to run without error. With exception handling, the program can resume operation after the error. The way exception handling works is that the program is trapped in the error state by the exception handler, the error is resolved, then the program is allowed to continue from that resolved state. The most simple way to handle exceptions is to abort the program as soon as the program encounters an exception, but this method is not ideal because the program is terminated at the error, instead of corrected. Exception handling is more useful than error codes because they can allow for stack tracing, allowing the programmer to easily see what is wrong during a debug.
\end{document}
