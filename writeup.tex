\documentclass{article}
\title{CS225 Final Project Writeup}
\author{Andrew Nolin \\ git@asnolin \and Jared Wiggett \\ git@jwiggett}
\date{\today}

\begin{document}
\maketitle
\section*{Simply Typed Lambda Calculus with Exceptions}
We have implemented small step semantics and typing relations for the simply typed lambda calculus extended with exception terms as defined in Chapter 14 of Benjamin C. Pierce's Types and Programming Languages.

\paragraph{Base Language: Phase I}
The base language we used was the simply typed lambda calculus from Chapter 9 of TAPL. This calculus contains terms (variables, abstractions, and applications), values, types and a typing context as well as small step semantics rules. To implement this, we started with the untyped lambda calculus of Chapter 5 of TAPL, which did not include types or a typing context. We implemented variables as strings, abstractions as a tuple containing a string and term, and application as a tuple of two terms. We didn't include types at first because Chapter 5 is untyped and therefore doesn't include them. Our only original value was the abstraction value, which was also modeled as a tuple of string and term. To implement a step function, we added a result type to our program enumerated as Stuck, Step of term, or Val of value. We also added helper functions for 'translating' values to terms for the step function, for finding the free variables in a given term, and for enforcing unique variables in a given term.
\paragraph{Base Language: Phase II}
After the implementation of the untyped lambda calculus of Chapter 5, we moved on to the implementation of the simply-typed lambda calculus of Chapter 9 in TAPL. This required the definition of types, of which we used only two at first: the Unit type and the Function type, which maps one type to another. In other words, our original terms were restricted to types Unit \(\rightarrow\) Unit \(\rightarrow\) ... of arbitrary length.
\end{document}
