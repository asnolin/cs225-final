\documentclass{article}
\title{CS225 Final Project Writeup}
\author{Andrew Nolin \\ git@asnolin \and Jared Wiggett \\ git@jwiggett}
\date{\today}

\begin{document}
\maketitle
\section*{Simply Typed Lambda Calculus with Exceptions}
We have implemented small step semantics and typing relations for the simply typed lambda calculus extended with exception terms as defined in Chapter 14 of Benjamin C. Pierce's Types and Programming Languages.

\paragraph{Base Language: Phase I}
The base language we used was the simply typed lambda calculus from Chapter 9 of TAPL. This calculus contains terms (variables, abstractions, and applications), values, types and a typing context as well as small step semantics rules. To implement this, we started with the untyped lambda calculus of Chapter 5 of TAPL, which did not include types or a typing context. We implemented variables as strings, abstractions as a tuple containing a string and term, and application as a tuple of two terms. We didn't include types at first because Chapter 5 is untyped and therefore doesn't include them. Our only original value was the abstraction value, which was also modeled as a tuple of string and term. To implement a step function, we added a result type to our program enumerated as Stuck, Step of term, or Val of value. We also added helper functions for 'translating' values to terms for the step function, for finding the free variables in a given term, and for enforcing unique variables in a given term.
\paragraph{Base Language: Phase II}
After the implementation of the untyped lambda calculus of Chapter 5, we moved on to the implementation of the simply-typed lambda calculus of Chapter 9 in TAPL. This required the definition of types, of which we used only two at first: the Unit type and the Function type, which maps one type to another. In other words, our original terms were restricted to types Unit \(\rightarrow\) Unit \(\rightarrow\) ... of arbitrary length.
\section*{Arith.ml}
In this file we went for an implimentation of a purely arithmetic language. It can be seen that numbers are equevelant to terms, and exceptions are represented in the res type. Solve completly reduces an expression of numbers using integer division and an always-positive modulo implimentation. It throws the IMAGINARY and DIV\textunderscore BY\textunderscore 0 res types, which in the simply typed lambda calculus, would be equivelant to exception types. It would have been embedded in the step function, where one step of a number would call solve and return the answer in one step. With this, it would be easier to see the exceptions it produces from more realistic expressions. The RError in the simply typed language that would represent the exceptions with a type 'number'. The testing segment at the end of the document was designed to check the logic in the solve function. There would have been a more robust testing suite in lang5.ml, but we did not get to it. 
\end{document}
